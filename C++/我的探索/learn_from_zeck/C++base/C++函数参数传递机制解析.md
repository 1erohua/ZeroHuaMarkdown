代码示例
```cpp
#include <iostream>

class T{
public:
    T(){}
    T(const T& t){
        std::cout << "拷贝构造函数调用" << std::endl;
    } 

    T(T&& t){
        std::cout << "移动构造函数调用" << std::endl;
    }
};

void Test1(T t){
    std::cout << "调用Test(T t)" << std::endl;
}

void Test2(T& t){
    std::cout << "调用Test(T& t)" << std::endl;
}

void Test3(T&& t){
    std::cout << "调用Test(T&& t)" << std::endl;
}

int main(){
    T t = T();

    // Test1按值接收，调用构造函数
    Test1(t);
    Test1(std::move(t));

    // Test2、Test3按引用接收，不调用构造函数
    Test2(t);
    Test3(std::move(t));
}
```


以下是整理后的表格，清晰展示了不同参数传递与接收方式对应的构造函数调用情况：


| **调用方传递方式**      | **函数接收方式**           | **调用的构造函数**       | **说明/示例**                                                                 |
|-------------------------|----------------------------|--------------------------|-------------------------------------------------------------------------------|
| **左值（`T`类型对象）**  | **按值接收（`T`）**         | 拷贝构造函数             | 传递非临时对象（如`T obj; func(obj);`）                                       |
| **右值（`T`类型临时对象）** | **按值接收（`T`）**         | 移动构造函数             | 传递`std::move(obj)`或临时对象（如`func(T())`）                               |
| **可隐式转换的类型（`U`）** | **按值接收（`T`）**         | 转换构造函数             | 传递类型`U`，但函数需要`T`（如`func(42)`，`T`有`T(int)`构造函数）              |
| **左值（`T`类型对象）**  | **左值引用（`T&`）**        | 无构造函数               | 引用直接绑定到左值（如`T obj; func(obj);`）                                   |
| **右值（`T`类型临时对象）** | **右值引用（`T&&`）**       | 无构造函数               | 引用直接绑定到右值（如`func(std::move(obj))`或`func(T())`）                   |
| **左值或右值（`T`）**    | **`const`左值引用（`const T&`）** | 无构造函数               | `const`左值引用可绑定到左值或右值（如`func(obj)`或`func(T())`）               |
| **可隐式转换的类型（`U`）** | **`const`左值引用（`const T&`）** | 转换构造函数             | 生成临时`T`对象并绑定到引用（如`func(42)`，调用`T(int)`构造临时对象）          |
| **可隐式转换的类型（`U`）** | **右值引用（`T&&`）**       | 转换构造函数             | 生成临时`T`对象后，右值引用绑定到该临时对象（如`func(42)`，调用`T(int)`构造） |

---

### **关键规则总结**：
1. **引用传递（`T&`/`T&&`/`const T&`）**  
   - 直接绑定对象，不触发构造函数。
   - 例外：当传递的类型需要隐式转换时，会构造临时对象（调用转换构造函数）。

2. **按值传递（`T`）**  
   - 必然触发构造函数：  
     - 左值 → 拷贝构造  
     - 右值 → 移动构造  
     - 隐式转换 → 转换构造  

3. **隐式转换场景**  
   - 无论按值、`const T&`还是`T&&`接收，只要类型不匹配但可转换，优先调用转换构造函数生成临时对象。
