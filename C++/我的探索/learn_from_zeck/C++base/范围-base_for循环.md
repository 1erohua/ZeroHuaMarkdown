这种 `for` 循环是 C++11 引入的**范围-based for 循环**（Range-based for loop），用于遍历容器（如 `std::vector`、`std::array`、`std::list` 等）或数组中的元素。

### 语法
```cpp
for (范围声明 : 范围表达式) {
    // 循环体
}
```

- **范围声明**：定义一个变量，用于存储每次迭代中从容器或数组中取出的元素。

  

  **注意注意注意！这里的取出元素本质是拷贝！因而要改变元素本身就需要引用！！！**

  **注意注意注意！这里的取出元素本质是拷贝！因而要改变元素本身就需要引用！！！**

  **注意注意注意！这里的取出元素本质是拷贝！因而要改变元素本身就需要引用！！！**

  

- **范围表达式**：通常是一个容器或数组，表示要遍历的范围。

### 示例代码解析
```cpp
std::cout << "vec2: ";
for (auto num : vec2) {
    std::cout << num << " ";
}
std::cout << std::endl;
```

- `auto num`：`auto` 关键字会自动推导 `vec2` 中元素的类型，`num` 是当前迭代的元素。
- `vec2`：是要遍历的容器（例如 `std::vector<int>`）。
- 每次迭代时，`num` 会依次取 `vec2` 中的每个元素，直到遍历完所有元素。

### 优点
1. **简洁**：不需要手动管理迭代器或下标。
2. **安全**：避免了越界访问的风险。
3. **通用**：适用于所有支持 `begin()` 和 `end()` 的容器。

### 注意事项
- 如果需要在循环中修改容器中的元素，可以使用引用：
  ```cpp
  for (auto& num : vec2) {
      num *= 2; // 修改元素
  }
  ```
- 如果**不需要修改元素，但希望避免拷贝**，可以使用 `const` 引用：
  ```cpp
  for (const auto& num : vec2) {
      std::cout << num << " ";
  }
  ```

### 与传统 `for` 循环的对比
传统 `for` 循环：
```cpp
for (size_t i = 0; i < vec2.size(); ++i) {
    std::cout << vec2[i] << " ";
}
```

范围-based `for` 循环更简洁，适合遍历容器或数组的场景。



# 如果在循环中修改容器中的元素，我直接使用变量修改而不使用引用修改，会发生什么？

如果在范围-based `for` 循环中直接使用变量（而不是引用）来修改容器中的元素，**实际上并不会修改容器中的原始元素**。这是因为变量是对容器中元素的**拷贝**，而不是对原始元素的引用。

### 示例代码
```cpp
std::vector<int> vec = {1, 2, 3, 4, 5};

for (auto num : vec) { // num 是 vec 中元素的拷贝
    num *= 2; // 修改的是拷贝，而不是原始元素
}

for (auto num : vec) {
    std::cout << num << " "; // 输出原始元素，未被修改
}
```

### 输出
```
1 2 3 4 5
```

### 原因
- `auto num` 会创建 `vec` 中每个元素的**拷贝**，`num` 是一个独立的变量，与容器中的元素无关。
- 修改 `num` 只会影响这个拷贝，而不会影响容器中的原始元素。

---

### 如何正确修改容器中的元素？
如果需要修改容器中的元素，必须使用**引用**（`&`），这样 `num` 就是容器中元素的别名，修改 `num` 会直接修改容器中的原始元素。

#### 正确代码
```cpp
std::vector<int> vec = {1, 2, 3, 4, 5};

for (auto& num : vec) { // num 是 vec 中元素的引用
    num *= 2; // 直接修改原始元素
}

for (auto num : vec) {
    std::cout << num << " "; // 输出修改后的元素
}
```

### 输出
```
2 4 6 8 10
```

---

### 总结
- 如果直接使用变量（`auto num`），修改的是元素的拷贝，不会影响容器中的原始元素。
- 如果需要修改容器中的元素，必须使用引用（`auto& num`）。
- 如果不需要修改元素，但希望避免拷贝，可以使用 `const` 引用（`const auto& num`）
