---
title: 认识头文件和源文件
date: 2024-09-08 09:14:44
tags: C++ cppbase
categories: C++ cppbase
---

## 头文件和源文件

在C++中，头文件（.h 或 .hpp 文件）和源文件（.cpp 文件）是组织代码的重要部分，它们共同工作以构建程序。这种分离**有助于模块化和代码重用**，同时也使得编译过程更加高效。

### 头文件（.h 或 .hpp）

头文件主要用于**声明**（declarations），包括：

- 类（class）的声明

- **函数（functions）的原型（prototypes）**

- **模板（templates）的声明**

- 宏定义（#define）

- 外部变量（extern variables）的声明

- **内联函数（inline functions）**

  > 华的插嘴：
  >
  > **什么是内联函数**？
  >
  > **内联函数**是一种特殊的函数，编译器在调用它时，会将它的代码直接“插入”到调用处，而不是通过正常的函数调用（比如压栈和跳转）。这样做的目的是为了提高效率。
  >
  > **通俗易懂的解释**：
  >
  > - 把内联函数想象成“直接把内容写在调用处的函数”。
  > - 平时你调用一个函数时，程序需要跳转到函数的内存地址去执行，再返回。而内联函数避免了这个过程，直接把函数的代码嵌入到调用的位置。
  > - 内联函数适用于代码短小且频繁调用的场景，比如`getter`或`setter`方法。

  > 什么是模板（**很像C#中的泛型**
  >
  > **模板**是C++中一种用于实现通用编程的工具。通俗地说，模板是一种“公式”或“蓝图”，它可以根据你提供的数据类型自动生成对应的代码。模板分为**函数模板**和**类模板**。
  >
  > #### 通俗易懂的解释：
  >
  > - 如果你想写一个函数或类，它可以处理多种数据类型，而不用重复写代码，模板就是你的好帮手。
  > - 比如你要实现一个“比较两个数的最大值”的函数，既希望支持`int`类型，又希望支持`float`、`double`甚至是自定义类型。模板可以帮你做到这一点，而不需要写多个版本的函数。
  >
  > 我的过往并非一无是处

头文件通常包含预处理指令如 `#ifndef`、`#define` 和 `#endif`，这些指令用于防止头文件被重复包含**（也称为“头文件保护”或“包含卫士”）。**

> 华：噢牛逼还能这样用的
>
> 如果没有定义xxx头文件（#ifndef xxx.h) ，那就定义xxx头文件(#define xxx.h)，然后最后再跟一个#endif

**示例头文件（example.h）**:

``` cpp
#ifndef EXAMPLE_H
#define EXAMPLE_H

class MyClass {
public:
    MyClass(); // 构造函数声明
    void myFunction(); // 成员函数声明
};

#endif
```

### 源文件（.cpp）

源文件包含**实际的代码实现**，即函数体、类的成员函数的实现等。源文件通常包括**必要的头文件**，以便编译器知道它们正在使用的函数、类等是如何声明的。

**示例源文件（example.cpp）**:

``` cpp
#include "example.h"
#include <iostream>

MyClass::MyClass() {
    // 构造函数实现
}

void MyClass::myFunction() {
    std::cout << "Hello from MyClass::myFunction!" << std::endl;
}
```

> 华：**自定义头文件**和**标准库自带的头文件**在引用和使用上有一些区别，主要体现在路径、引用方式、语法和编译流程等方面。
> **自带头文件通常用< >包围，自定义头文件通常用" "包围**
>
> 使用**尖括号**的含义是，编译器会在**标准库的搜索路径中查找这些头文件**。
>
> 使用**双引号**的含义是，编译器会先在**当前文件所在的目录或用户指定的路径中查找该头文件**。如果找不到，**再转而查找标准库路径。**

### 编译过程

在编译C++程序时，编译器会首先处理源文件（.cpp 文件）。对于源文件中的每个 `#include` 指令，编译器都会查找并包含相应的头文件（.h 或 .hpp 文件）。然后，编译器将处理源文件中的所有实现代码，并将它们与从头文件中获取的声明进行匹配。

### 注意事项

- 头文件应该只包含声明，源文件应该包含实现。
- 使用**头文件保护**来避免头文件被重复包含。(ifndef xxx define xxx endif)
- 在大型项目中，合理组织头文件和源文件可以提高项目的可维护性和可扩展性。
- 在编译时，确保所有的源文件都被编译，并且所有的头文件都被正确包含。

通过这种方式，C++程序的结构变得更加清晰和模块化，有利于多人协作和代码重用。

`#pragma once` 和 宏定义（如 `#ifndef, #define, #endif`）都是用来防止头文件被重复包含的机制，但它们在工作方式和使用场景上存在一些区别。

## `pragma once`

### `pragma once`作用

- **工作方式**：`#pragma once` 是一个**非标准的但广泛支**持的预处理指令**，它告诉编译器该头文件在单个编译过程中只应被包含一次。**编译器在第一次遇到 `#pragma once` 时会记住该文件名，并在后续的包含操作中忽略它。
- **优点**：简单、直观、易于使用。不需要生成唯一的宏名，减少了出错的可能性。
- **缺点**：不是 C++ 标准的一部分，尽管大多数现代编译器都支持它，但在某些旧的或特定的编译器中可能不受支持。
- **使用场景**：在支持 `#pragma once` 的编译器中，推荐使用它作为防止头文件重复包含的首选方法。

### 宏定义（`#ifndef, #define, #endif`）

- **工作方式**：通过宏定义（通常称为“包含卫士”或“头文件保护”）来防止头文件被重复包含。首先检查一个特定的宏是否已定义，如果没有定义，则定义它并包含头文件的其余部分。如果宏已经定义，则跳过头文件的其余部分。
- **优点**：是 C++ 标准的一部分，因此在所有 C++ 编译器中都是可用的。
- **缺点**：需要为每个头文件生成一个唯一的宏名，这可能会增加出错的机会（例如，如果两个头文件不小心使用了相同的宏名）。
- **使用场景**：在需要确保代码与所有 C++ 编译器兼容时，或者在不支持 `#pragma once` 的编译器中，使用宏定义来防止头文件重复包含。

### 总结

尽管 `#pragma once` 和 宏定义在功能上相似，但它们在实现方式和使用场景上有所不同。在大多数现代 C++ 项目中，推荐使用 `#pragma once`，因为它更简单、更直观，并且大多数现代编译器都支持它。然而，**在需要确保与所有 C++ 编译器兼容的情况下**，或者在不支持 `#pragma once` 的环境中，仍然需要使用宏定义来防止头文件被重复包含。

## 程序如何编译的

### g++编译

> g++是GNU（GNU's Not Unix）项目开发的C++编译器，它是GCC（GNU Compiler Collection，GNU编译器套件）的一个重要组成部分。GCC是一个支持多种编程语言的编译器集合，而g++则专门用于编译C++代码。



>- 在使用g++编译C++程序时，可能需要安装GCC或g++编译器。在大多数Linux发行版和Unix系统中，GCC和g++通常作为标准软件包的一部分进行安装。在Windows系统中，则可能需要下载并安装MinGW或Cygwin等工具来提供GCC和g++的支持。



当使用 `g++` 编译器编译 `main.cpp` 并希望包含相关的头文件时，你实际上不需要在编译命令中直接指定头文件。**编译器会在编译过程中自动查找并包含你在 `main.cpp` 或其他已包含的头文件中通过 `#include` 指令指定的头文件。**

然而，如果你的头文件**位于非标准路径（即不在编译器的默认搜索路径中**），你可能需要使用 `-I` 选项来指定额外的头文件搜索路径。

假设你的**头文件 `example.h` 位于与 `main.cpp` 相同的目录下，或者位于编译器默认搜索的头文件路径中，你可以简单地使用以下命令来编译 `main.cpp`：**

``` bash
g++ main.cpp -o myprogram
```

这里，`-o myprogram` 指定了输出文件的名称（在这个例子中是 `myprogram`）。如果你没有指定 `-o` 选项，编译器通常会生成一个名为 `a.out` 的可执行文件（在 Unix-like 系统中）。

如果你的头文件位于不同的目录，比如 `include` 目录，并且 `main.cpp` 中包含了 `#include "example.h"`，你需要使用 `-I` 选项来告诉编译器在哪里查找这个头文件：

``` bash
g++ -Iinclude main.cpp -o myprogram
```

在这个例子中，`-Iinclude` 告诉编译器在 `include` 目录下查找头文件。**注意，`-I` 选项后面紧跟的是目录名，而不是文件名。**

如果你的项目包含多个源文件（`.cpp` 文件）和/或多个头文件，并且它们位于不同的目录中，

**你可能还需要使用 `-L` 选项来指定库文件的搜索路径（如果你链接了外部库的话）**，以及使用 `-l` 选项来指定要链接的库名（**去掉前缀 `lib` 和后缀 `.so` 或 `.a`**）。但是，对于仅包含头文件和源文件的简单项目，通常只需要上述的编译命令即可。

### `CMake`跨平台编译(重要、收获颇丰	)

`CMake`是一个跨平台的自动化构建系统，它使用`CMakeLists.txt`文件来描述构建过程。下面是一个`CMake`的基本写法示例，这将指导你如何编写一个简单的`CMakeLists.txt`文件来构建一个可执行文件。

#### 示例：构建单个可执行文件

假设你有一个`C++`源文件`main.cpp`，你想用`CMake`来构建它。首先，你需要创建一个名为`CMakeLists.txt`的文件，通常这个文件位于你的项目根目录下。

``` bash
# 设置CMake最小版本要求
cmake_minimum_required(VERSION 3.10)

# 设置项目名称和版本
project(MyProject VERSION 1.0)

# 添加一个可执行文件
# 语法：add_executable(目标名 源文件...)
add_executable(MyExecutable main.cpp)
```

在这个例子中：

- `cmake_minimum_required(VERSION 3.10)`：这行设置了CMake构建系统的最小版本要求。你需要确保你的CMake版本至少是3.10或更高。
- `project(MyProject VERSION 1.0)`：这行设置了项目的名称（`MyProject`）和版本（`1.0`）。这个命令也会创建一个变量`${PROJECT_NAME}`和`${MyProject_VERSION}`，尽管直接使用`MyProject_VERSION`不是强制的，因为CMake通常建议使用`${PROJECT_VERSION}`来引用版本。
- `add_executable(MyExecutable main.cpp)`：**这行定义了一个可执行文件目标**。它告诉CMake你想将`main.cpp`编译成一个名为`MyExecutable`的可执行文件。构建时，CMake将自动找到适合你的平台的编译器和编译选项，并将`main.cpp`编译成可执行文件。

#### 构建项目

在命令行中，首先进入包含`CMakeLists.txt`的目录，然后运行以下命令来配置CMake项目（这将生成一个构建系统，如Makefile）：

``` bash
mkdir build  # 创建一个名为build的目录（不是必须的，但推荐）
cd build
cmake ..     # 使用上级目录中的CMakeLists.txt配置项目
```

配置完成后，你可以使用生成的构建系统来构建项目。如果你使用的是Makefile（大多数Unix-like系统），则可以运行：

``` bash
make
```

这将编译你的项目，并生成可执行文件（在这个例子中是`MyExecutable`）。如果你是在Windows上，并且CMake配置的是生成Visual Studio项目文件，那么你需要使用Visual Studio来打开生成的项目文件并构建项目。

#### 注意

- `CMake`是一个非常强大的构建系统，支持多种编程语言、复杂的目标关系、库依赖、条件编译等高级功能。上面的例子仅展示了最基础的用法。
- 总是建议使用一个单独的构建目录（如上面的`build`目录），这样就不会污染你的源代码目录。
- `CMake`提供了大量的命令和变量，可以用来精确控制构建过程。建议查阅`CMake`的官方文档以了解更多信息。



## 来自华的补充

`cmake ..` 和 `make` 是在构建 C++ 等项目时常用的两个命令，它们各自有不同的作用和职责：

------

### 1. **`cmake ..`**

- **作用**：生成构建系统文件（例如 `Makefile`）。
- **过程**：
  - `cmake` 是一个跨平台的构建系统生成工具。它通过读取项目中的 `CMakeLists.txt` 文件，生成与当前操作系统和编译器兼容的构建系统文件。
  - `cmake ..` 的 `..` 表示项目的根目录（通常包含 `CMakeLists.txt` 文件）。
  - 执行后，`cmake` 会生成一个 `Makefile`（如果使用的是默认生成器），或者其他适合目标环境的构建文件。
- **总结**：`cmake ..` 只是准备工作，它生成的是构建规则和配置。

------

### 2. **`make`**

- **作用**：根据 `Makefile` 执行实际的编译、链接过程。

- 过程

  ：

  - `make` 使用由 `cmake` 生成的 `Makefile`。
  - 它解析 `Makefile`，按照里面定义的规则执行编译、链接等操作，生成可执行文件或库。

- **总结**：`make` 是实际执行构建任务的工具，利用 `Makefile` 来完成任务。

------

### 二者的关系：

- **`cmake` 是工具链的配置阶段，`make` 是执行阶段。**
- 工作流程通常是：
  1. 用 `cmake ..` 生成构建系统。
  2. 用 `make` 执行生成的构建规则，完成项目的编译。

------

### 举例：

假设你的项目目录结构如下：

```
project/
├── CMakeLists.txt
├── src/
│   └── main.cpp
```

1. 在 `project/` 目录中运行：

   ```bash
   mkdir build
   cd build
   cmake ..
   ```

   - 结果：在 `build/` 目录下生成构建系统文件，比如 `Makefile`。

2. 再运行：

   ```bash
   make
   ```

   - 结果：根据生成的 `Makefile` 编译项目，生成可执行文件。

------

### 常见问题：

1. **为什么需要分两步？**
   - 分离生成构建系统和执行构建的步骤，使 `cmake` 能够支持不同的构建工具（例如 Ninja），提高灵活性。
2. **可以直接用 `make` 而不经过 `cmake` 吗？**
   - 如果有手写的 `Makefile`，可以直接用 `make`，但这不适合复杂的项目。`cmake` 自动化生成构建规则，可以适应不同平台和编译器的需求。

> CMake太牛逼了只能说，尤其是根据不同的操作系统自动构建Makefile文件


