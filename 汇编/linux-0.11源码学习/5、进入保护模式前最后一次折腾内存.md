# 自思考时刻

start代码一进门就是把数据段移到这附近，即0x90200附近，0x90000
![[Pasted image 20250205130939.png]]

 **int 0x10**: 触发 BIOS 提供的**显示服务**中断处理程序，执行完毕后在dx存储光标地址
**ah** 寄存器被赋值为 **0x03** 表示显示服务里具体的**读取光标位置功能**。
dx现状：![[Pasted image 20250205131131.png ]]，高八位行号，低八位列号

**mov [0],dx**——这个内存地址仅仅是偏移地址

后面的代码也是设置中断获取信息


```assembly
! setup.s 负责从BIOS获取系统数据，并将它们放置在系统内存的适当位置。
! setup.s 和 system 都被 bootblock 加载。
!
! 该代码向 BIOS 请求内存/磁盘/其他参数，并将它们放在一个“安全”的位置：0x90000-0x901FF，即 bootblock 之前所在的位置。
! 然后由保护模式系统在该区域被覆盖为缓冲区之前读取这些数据。

! 注意！这些必须与 bootsect.s 中的相同！

INITSEG  = 0x9000  ! boot 被移动到这里，远离原位置
SYSSEG   = 0x1000  ! 系统加载在 0x10000 (65536)
SETUPSEG = 0x9020  ! 当前段

.globl begtext, begdata, begbss, endtext, enddata, endbss
.text
begtext:
.data
begdata:
.bss
begbss:
.text

entry start
start:

! 读取光标位置并保存

	mov	ax,#INITSEG  ! 将数据段移动到 0x90000
	mov	ds,ax

	mov	ah,#0x03     ! 读取光标位置
	xor	bh,bh
	int	0x10         ! 保存在已知位置，con_init 从 0x90000 读取
	mov	[0],dx        ! 保存光标位置

! 获取内存大小（扩展内存，kB）

	mov	ah,#0x88
	int	0x15
	mov	[2],ax        ! 保存内存大小

! 获取视频卡数据

	mov	ah,#0x0f
	int	0x10
	mov	[4],bx        ! bh = 显示页面
	mov	[6],ax        ! al = 视频模式，ah = 窗口宽度

! 检查 EGA/VGA 和一些配置参数

	mov	ah,#0x12
	mov	bl,#0x10
	int	0x10
	mov	[8],ax        ! 保存 EGA/VGA 信息
	mov	[10],bx
	mov	[12],cx

! 获取硬盘 0 数据

	mov	ax,#0x0000
	mov	ds,ax
	lds	si,[4*0x41]  ! 读取硬盘 0 的数据
	mov	ax,#INITSEG
	mov	es,ax
	mov	di,#0x0080
	mov	cx,#0x10
	rep
	movsb           ! 复制硬盘 0 数据到内存

! 获取硬盘 1 数据

	mov	ax,#0x0000
	mov	ds,ax
	lds	si,[4*0x46]  ! 读取硬盘 1 的数据
	mov	ax,#INITSEG
	mov	es,ax
	mov	di,#0x0090
	mov	cx,#0x10
	rep
	movsb           ! 复制硬盘 1 数据到内存

! 检查是否存在硬盘 1

	mov	ax,#0x01500
	mov	dl,#0x81
	int	0x13
	jc	no_disk1      ! 如果没有硬盘 1，跳转
	cmp	ah,#3
	je	is_disk1      ! 如果是硬盘 1，继续
no_disk1:
	mov	ax,#INITSEG
	mov	es,ax
	mov	di,#0x0090
	mov	cx,#0x10
	mov	ax,#0x00
	rep
	stosb           ! 清空硬盘 1 数据区域

```

![[Pasted image 20250205155006.png]]

存好信息——关闭中断：
```asm
cli         ; no interrupts allowed ;
```



下一步
```
! 首先我们将系统移动到正确的位置

	mov	ax,#0x0000
	cld             ! 方向=0，movs 向前移动
do_move:
	mov	es,ax        ! 目标段
	add	ax,#0x1000
	cmp	ax,#0x9000
	jz	end_move
	mov	ds,ax        ! 源段
	sub	di,di
	sub	si,si
	mov	cx,#0x8000
	rep
	movsw           ! 复制数据
	jmp	do_move
```
关于
**这段汇编的解释在后面的汇编解释1**

同前面的原理一样，也是做了个内存复制操作，最终的结果是，把内存地址 **0x10000** 处开始往后一直到 **0x90000** 的内容，统统复制到内存的最开始的 **0** 位置，大概就是这么个效果。
![[Pasted image 20250205162002.png]]











# AI时刻


### 深度解析操作系统启动阶段 setup.s 的关键操作

---

#### **一、核心流程概述**
本文描述了操作系统启动过程中从`bootsect.s`到`setup.s`的过渡阶段，重点包括：
1. **调用BIOS中断收集硬件信息**（光标位置、内存大小、显卡参数、硬盘信息）
2. **调整内存布局**：将内核代码（`system`模块）移动到内存起始位置
3. **准备进入保护模式**：关闭中断，为后续模式切换做准备

---

#### **二、BIOS中断调用与硬件信息收集**
##### 1. 光标位置获取（`int 0x10`）
```nasm
mov ah, #0x03    ; 功能号03h（读取光标位置）
xor bh, bh       ; 显示页面号（0）
int 0x10         ; 调用BIOS中断
mov [0], dx      ; 保存到0x90000（ds=0x9000）
```
- **返回值**：DH=行号，DL=列号（25x80文本模式）
- **内存存储**：`0x90000`处存储光标位置，供后续控制台初始化使用

##### 2. 扩展内存检测（`int 0x15`）
```nasm
mov ah, #0x88    ; 功能号88h（获取扩展内存大小）
int 0x15
mov [2], ax      ; 存储到0x90002（单位：KB）
```
- **返回值**：AX=扩展内存大小（1MB以上内存）

##### 3. 显卡信息获取（`int 0x10`多组调用）
- 获取当前显示模式（AH=0x0F）
- 检查EGA/VGA参数（AH=0x12, BL=0x10）
- 存储显示模式、屏幕行列数等至`0x90004`~`0x9000F`

##### 4. 硬盘参数获取（`int 0x41/0x46`）
```nasm
lds si, [4*0x41] ; 加载硬盘1参数表地址（BIOS中断向量表位置）
rep movsb        ; 复制16字节到0x90080
```
- **硬盘参数表**：包含柱面数、磁头数、扇区数等关键信息
- **存储位置**：硬盘1参数表在`0x90080`，硬盘2在`0x90090`

---

#### **三、内存布局调整**
##### 1. 关键代码片段
```nasm
mov ax, #0x0000  ; 目标段地址（0x0000）
mov es, ax       ; ES:DI = 0x0000:0x0000
mov ds, ax       ; 源段地址递增（0x1000, 0x2000...）
rep movsw        ; 每次复制0x8000字（64KB）
```
- **操作目的**：将`system`模块从`0x10000`移动到`0x00000`
- **循环逻辑**：每次复制64KB数据，直到完成`0x10000`到`0x90000`的迁移

##### 2. 内存布局变化
| 地址范围            | 内容                              |
| --------------- | ------------------------------- |
| 0x00000~0x7FFFF | system模块（512KB） —— 被移动的system模块 |
| 0x90000~0x901FF | 硬件参数表（512B）                     |
| 0x90200~0x9FFFF | setup.s代码                       |
| 0x9FF00~        | 栈空间                             |

![[Pasted image 20250205163836.png]]

#### **四、关键技术解析**
##### 1. 实模式内存寻址
- **段地址+偏移量**：`DS:SI`的实际地址为`DS*16 + SI`
  - 示例：`DS=0x9000`时，`[0]`对应物理地址`0x90000`

##### 2. 数据传递机制
- **约定内存地址**：汇编与后续C代码通过固定地址共享数据
  - 示例：光标位置存储在`0x90000`，C代码直接读取该地址

##### 3. 中断管理
- **CLI指令**：关闭中断响应
  - **必要性**：后续将覆盖BIOS中断向量表，防止中断引发不可预测行为

##### 4. 保护模式准备
- **前置条件**：
  1. 硬件信息收集完成
  2. 内核代码移动到正确位置
  3. 中断向量表即将重建

---

#### **五、关键寄存器与指令**
| 寄存器 | 作用                         |
|--------|------------------------------|
| AX     | 功能参数/返回值              |
| DS/ES  | 数据段/附加段寄存器          |
| SI/DI  | 源/目标偏移指针              |
| CX     | 控制`rep`指令的循环次数      |

| 指令     | 功能                          |
|----------|-------------------------------|
| `int x`  | 调用BIOS中断服务              |
| `rep movsw` | 批量复制数据（字为单位）     |
| `cld`    | 设置方向标志（SI/DI递增）     |

---

#### **六、设计意图与原理**
4. **硬件抽象层构建**
  通过BIOS中断获取硬件参数，避免直接操作硬件，提高兼容性。

5. **内存空间优化**
  将内核代码移动到`0x00000`，确保后续保护模式中代码与数据段的连续性。

6. **平滑模式过渡**
  关闭中断、收集必要信息，为加载全局描述符表（GDT）和开启A20地址线做准备。

7. **数据共享设计**
  通过固定内存地址传递参数，规避汇编与C语言混合编程的复杂性。

---

#### **七、后续关键步骤预告**
8. **加载全局描述符表（GDT）**
9. **开启A20地址线**
10. **设置CR0寄存器进入保护模式**
11. **跳转到32位内核入口**

通过这一系列操作，计算机将彻底脱离16位实模式，进入现代操作系统赖以运行的32位保护模式环境。


# 汇编解释1



这段汇编代码的作用是将内存中从0x1000段开始的多个64KB数据块依次向下移动一个段的位置，最终将512KB数据移动到低地址区域。以下是详细分析：

---

### **代码逐行解析**
1. **初始化阶段**
   ```asm
   mov ax, #0x0000   ; 初始化AX为0x0000
   cld               ; 清除方向标志（DF=0），确保movsw向前移动
   ```

2. **循环主体 (`do_move`标签)**
   ```asm
   do_move:
       mov es, ax       ; 目标段地址 = AX当前值
       add ax, #0x1000  ; AX += 0x1000（段地址递增64KB）
       cmp ax, #0x9000  ; 检查AX是否达到0x9000
       jz end_move      ; 如果AX=0x9000，结束循环
       mov ds, ax       ; 源段地址 = AX的新值（比目标段高0x1000）
       sub di, di       ; 目标偏移DI清零
       sub si, si       ; 源偏移SI清零
       mov cx, #0x8000  ; 设置重复次数为0x8000（32,768次）
       rep movsw        ; 重复执行movsw，复制2字节*32,768=64KB数据
       jmp do_move      ; 继续下一轮循环
   ```

3. **循环结束 (`end_move`标签)**
   ```asm
   end_move:
       ; 后续代码（此处未展示）
   ```

---

### **关键流程说明**
4. **内存移动逻辑**
   - 每次循环将**高地址段（DS）的64KB数据**复制到**低地址段（ES）**。
   - 源段和目标段的对应关系：
     - 第1次循环：复制 `DS=0x1000` → `ES=0x0000`
     - 第2次循环：复制 `DS=0x2000` → `ES=0x1000`
     - ...
     - 第8次循环：复制 `DS=0x8000` → `ES=0x7000`

5. **终止条件**
   - 当 `AX` 递增到 `0x9000` 时，跳出循环。此时已完成 **8次数据移动**，总计复制 **8×64KB = 512KB**。

6. **段地址与物理地址转换**
   - 实模式下，段寄存器值需左移4位得到基地址：
     - `ES=0x0000` → 物理地址 `0x00000`
     - `DS=0x1000` → 物理地址 `0x10000`
     - 每次段地址递增 `0x1000`，对应物理地址递增 `0x10000`（64KB）。

---

### **代码作用总结**
- **目标**：将内存中 `0x10000` 到 `0x8FFFF`（共512KB）的数据，整体向下移动到 `0x00000` 到 `0x7FFFF`。
- **典型场景**：在系统引导阶段，将加载到高地址的内核代码/数据移动到低地址，确保后续正确执行。

---

### **示意图**
```
物理地址范围        操作
0x00000-0x0FFFF  ← 复制自 0x10000-0x1FFFF（第1次循环）
0x10000-0x1FFFF  ← 复制自 0x20000-0x2FFFF（第2次循环）
...
0x70000-0x7FFFF  ← 复制自 0x80000-0x8FFFF（第8次循环）
```

通过这种方式，代码完成了内存数据的“整体搬迁”，常用于操作系统启动时的关键初始化步骤。