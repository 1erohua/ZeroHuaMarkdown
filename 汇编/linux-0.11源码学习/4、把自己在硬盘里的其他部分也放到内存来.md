# 前瞻的思考
复习：开幕雷击
![[Pasted image 20250205095844.png]]


上一回讲了什么？
就是设置了如何访问数据的**数据**段，如何访问代码的**代码**段，以及如何访问栈的**栈顶**指针，也即初步做了一次**内存规划**


本集关键代码：
### load_setup
```asm
load_setup:

mov dx,#0x0000 ! drive 0, head 0

mov cx,#0x0002 ! sector 2, track 0

mov bx,#0x0200 ! address = 512, in INITSEG

mov ax,#0x0200+SETUPLEN ! service 2, nr of sectors

int 0x13 ! read it

jnc ok_load_setup ! ok - continue

! 重试操作

! `jnc`(Jump if No Carry)指令根据`int 0x13`执行后设置的进位标志（CF）决定跳转：

! - CF=0：读取成功，跳转到ok_load_setup

! - CF=1：读取失败，执行后续错误处理

mov dx,#0x0000

mov ax,#0x0000 ! reset the diskette

int 0x13

j load_setup

  

ok_load_setup:
```

> 0x13 号中断的处理程序是 BIOS 提前给我们写好的，是**读取磁盘**的相关功能的函数。



### ok_load_setup
```asm
! 获取磁盘驱动器参数（特别是每磁道扇区数）

    mov    dl,#0x00        ! DL=0 表示第一个软盘驱动器
    mov    ax,#0x0800      ! AH=8 表示获取驱动器参数的BIOS功能
    int    0x13            ! 调用BIOS 13h中断
    mov    ch,#0x00        ! 清空CH（柱面数高8位清零）
    seg cs                 ! 显式指定使用CS段寄存器
    mov    sectors,cx      ! 将CX（包含每磁道扇区数）存入sectors变量
                           ! CL低6位：每磁道扇区数
                           ! CH | CL高2位：柱面数（这里被清零）

    mov    ax,#INITSEG     ! 初始化ES段寄存器为INITSEG（0x9000）
    mov    es,ax

! 打印提示信息（引导消息）

    mov    ah,#0x03        ! AH=3 获取光标位置
    xor    bh,bh           ! BH=0 表示第0页
    int    0x10            ! 调用BIOS 10h中断

    mov    cx,#24          ! 要打印的字符串长度（24字符）
    mov    bx,#0x0007      ! BH=0页，BL=07h属性（灰底黑字）
    mov    bp,#msg1        ! ES:BP指向消息地址（msg1）
    mov    ax,#0x1301      ! AH=13h写字符串，AL=01h移动光标
    int    0x10            ! 调用BIOS 10h中断
	
! 开始加载系统到内存0x10000（SYSSEG=0x1000）
	!重要
    mov    ax,#SYSSEG      ! AX=0x1000（对应物理地址0x10000）
    mov    es,ax           ! ES=0x1000  
    call   read_it         ! 调用磁盘读取例程
    !重要
    call   kill_motor      ! 关闭软盘马达
	
	
! 确定根设备类型（root device）

    seg cs                 
    mov    ax,root_dev     ! 加载当前root_dev值
    cmp    ax,#0           ! 检查是否已定义
    jne    root_defined    ! 如果已定义则跳过检测

    seg cs
    mov    bx,sectors      ! 加载之前获取的每磁道扇区数
    mov    ax,#0x0208      ! 预设设备号为0x0208（/dev/ps0，1.2MB软盘）
    cmp    bx,#15          ! 检查是否是15扇区/磁道
    je     root_defined    ! 如果是15则使用0x0208

    mov    ax,#0x021c      ! 否则尝试0x021c（/dev/PS0，1.44MB软盘）
    cmp    bx,#18          ! 检查是否是18扇区/磁道
    je     root_defined    ! 如果是18则使用0x021c

undef_root:                ! 未知磁盘类型处理
    jmp undef_root         ! 死循环（系统停止）

root_defined:              ! 有效设备类型处理
    seg cs
    mov    root_dev,ax     ! 存储确定的设备号

! 跳转到setup程序（位于SETUPSEG段）
	！重要
    jmpi    0,SETUPSEG     ! 远跳转到SETUPSEG:0（通常为0x9020:0）
	！重要
```



# AI有话说
### 文章核心内容解析

---

#### **1. 内存规划阶段**
**关键代码分析**：
```nasm
mov ds, 0x9000    ; 数据段寄存器
mov cs, 0x9000    ; 代码段寄存器
mov ss, 0x9000    ; 栈段寄存器
mov sp, 0xFF00    ; 栈顶指针
```
**原理与意图**：
- **分段机制**：在实模式下，CPU 通过 `段寄存器:偏移地址` 访问内存。`ds`（数据段）和 `cs`（代码段）设置为 `0x9000`，对应物理地址 `0x90000`（计算方式：`0x9000 << 4 + 0x0000`）。
- **栈安全设计**：栈顶 `ss:sp = 0x9000:0xFF00`，对应物理地址 `0x9FF00`，远离代码区 `0x90000`，避免栈向下增长覆盖代码。

---

#### **2. 加载 setup.s 模块**
**关键代码分析**：
```nasm
load_setup:
    mov dx, 0x0000   ; DL=驱动器号 (0=软盘), DH=磁头号 (0)
    mov cx, 0x0002   ; CH=磁道号 (0), CL=起始扇区号 (2)
    mov bx, 0x0200   ; ES:BX=目标地址 (0x9000:0x0200 → 0x90200)
    mov ax, 0x0204   ; AH=0x02 (读磁盘功能), AL=4 个扇区
    int 0x13         ; 调用 BIOS 中断读取磁盘
```
**原理与意图**：
- **BIOS 中断调用**：`int 0x13` 是 BIOS 磁盘服务中断，参数通过寄存器传递：
  - `AH=0x02`：读磁盘功能
  - `AL=4`：读取 4 个扇区
  - `CH/CL`：磁道和扇区号（硬盘第 2 扇区）
  - `ES:BX`：目标地址 `0x90200`（`0x9000 << 4 + 0x0200`）
- **错误处理**：若失败（进位标志 CF=1），重置磁盘并重试。
人话：从磁盘的第二个扇区（起始扇区号2开始，将数据加载到内存0x90200），共加载四个扇区。
![[Pasted image 20250205111850.png]]

---

#### **3. 加载 system 模块**
作者原话：
这段代码省略了很多非主逻辑的代码，比如在屏幕上输出 Loading system ... 这个字符串以防止用户等烦了。

实际上整片的源代码：在上面给出了

**关键代码分析**：
```nasm
ok_load_setup:
    mov ax, 0x1000   ; 目标段地址 0x1000
    mov es, ax       ; ES=0x1000 → 物理地址 0x10000
    call read_it     ; 自定义函数读取 240 个扇区
    jmpi 0, 0x9020   ; 段间跳转到 0x9020:0x0000 → 0x90200
```

其中的read_it
```
read_it:
    mov ax,es        ; 检查内存对齐
    test ax,#0x0fff
die:
    jne die          ; 死循环（若未对齐）
    xor bx,bx        ; 初始化段内偏移bx=0

rp_read:
    ; ... 循环读取逻辑 ...
    call read_track  ; 调用磁道读取函数
    ; ... 段边界处理 ...
    ret              ; 函数返回
```
### **`read_it` 的工作逻辑**

无论实际扇区数是多少，`read_it` 的加载逻辑是通用的：

1. **按磁道读取**：  
    通过 BIOS 中断 `int 0x13` 读取整个磁道的扇区，提升加载效率。
2. **内存边界处理**：  
    确保每次读取不跨越 64 KB 段边界，通过调整 `ES` 段寄存器实现。
3. **终止条件**：  
    持续加载直到 `ES` 段达到 `ENDSEG`（代码中的终止条件）。


**原理与意图**：
	- **system 模块加载**：从硬盘第 6 扇区开始读取 240 个扇区到内存 `0x10000`。
- **跳转到 setup.s**：`jmpi 0, 0x9020` 跳转到 `0x90200`（`0x9020 << 4 + 0x0000`），执行 `setup.s` 的第一条指令。
![[Pasted image 20250205113138.png]]

---

#### **4. 编译与硬盘布局**
**编译流程**：
4. **bootsect.s** → 编译为 512 字节 → 写入硬盘第 1 扇区。
5. **setup.s** → 编译为 4 扇区 → 写入第 2-5 扇区。
6. **system 模块**（含 head.s）→ 编译为 240 扇区 → 写入后续扇区。

**内存-硬盘映射关系**：
```
硬盘布局：
| Sector 1 (bootsect) | Sectors 2-5 (setup) | Sectors 6-245 (system) |
内存布局：
| 0x7C00 (bootsect)   | 0x90200 (setup)     | 0x10000 (system)       |
```

![[Pasted image 20250205113510.png]]


---

#### **5. 强耦合设计分析**
**关键设计挑战**：
- **绝对地址依赖**：所有跳转地址（如 `jmpi 0, 0x9020`）必须与编译后的代码位置严格匹配。
- **手工内存规划**：需精确计算：
  - `setup.s` 必须位于硬盘第 2 扇区 → 加载到内存 `0x90200`。
  - `system` 必须从硬盘第 6 扇区开始 → 加载到 `0x10000`。

**设计权衡**：
- **优点**：完全控制底层细节，无动态加载开销。
- **缺点**：代码与物理布局强绑定，修改需重新计算地址。

---

#### **6. 寄存器与内存访问**
**寄存器角色**：

| 寄存器   | 作用                       | 示例值            | 物理地址计算            |
| ----- | ------------------------ | -------------- | ----------------- |
| CS    | 代码段基址 (0x9000)           | 0x9000         | 0x90000 (CS << 4) |
| DS    | 数据段基址 (0x9000)           | 0x9000         | 0x90000           |
| SS:SP | 栈顶地址 (0x9000:0xFF00)     | 0x9000, 0xFF00 | 0x9FF00           |
| ES:BX | 磁盘读取目标地址 (0x9000:0x0200) | 0x9000, 0x0200 | 0x90200           |
|       |                          |                |                   |

---

### 图表辅助说明
#### **内存布局示意图**
```
0x00000 ┌───────────────┐
        │ BIOS 中断向量 │
0x00400 ├───────────────┤
        │ 硬盘参数表    │
0x7C00  ├───────────────┤ ← bootsect.s (512 字节)
0x7E00  ├───────────────┤
        │ 空闲区域      │
0x90000 ├───────────────┤ ← DS/CS/SS 基址
0x90200 ├───────────────┤ ← setup.s 加载位置
0x9FF00 ├───────────────┤ ← 栈顶 (向下增长)
0x10000 ├───────────────┤ ← system 模块加载位置
        │               │
```

---

### 总结
7. **内存规划**：通过分段寄存器和栈指针，严格划分代码、数据和栈区域。
8. **磁盘加载**：利用 BIOS 中断 `int 0x13` 分阶段加载操作系统模块到指定内存地址。
9. **强耦合设计**：代码位置与物理地址严格绑定，需手工确保编译后布局正确。
10. **启动流程**：`bootsect.s` → `setup.s` → `system`，逐步移交控制权。

此阶段是操作系统启动的基石，后续所有功能（如保护模式、内存管理）均建立在此精确的内存和磁盘布局之上。


## 错误处理部分代码的补充


你观察得非常仔细！这部分代码是磁盘读取操作的关键错误处理机制，我们展开详细分析：

11. **条件跳转指令**：
```asm
jnc ok_load_setup ; 进位标志为0时跳转
```
- `jnc`（Jump if No Carry）指令根据`int 0x13`执行后设置的进位标志（CF）决定跳转：
  - CF=0：读取成功，跳转到ok_load_setup
  - CF=1：读取失败，执行后续错误处理

12. **错误处理流程**：
```asm
mov dx,#0x0000     ; 驱动器号DL=0（软盘A），磁头号DH=0
mov ax,#0x0000     ; AH=0（磁盘复位功能）
int 0x13           ; 再次调用磁盘服务
jmp load_setup     ; 重新尝试读取
```

13. **寄存器参数详解**：
   - **AH=0x00**：BIOS磁盘复位功能
   - **DL=0x00**：驱动器号（00h-7Fh为软盘，80h-FFh为硬盘）
   - 其他寄存器在复位操作中不需要设置

14. **磁盘服务示意图**：
```
+------------------+
|   读取磁盘操作   |
| (int 0x13 AH=02) |
+------------------+
         |
         v
+------------------+    成功
| 检查CF标志位     |---------> 继续执行
+------------------+    失败
         |
         v
+------------------+
| 复位磁盘控制器   |
| (int 0x13 AH=00) |
+------------------+
         |
         v
+------------------+
| 重新尝试读取     |
+------------------+
```

15. **设计原理**：
- **硬件容错**：早期软盘/磁头机械结构不稳定，需要多次尝试
- **关键数据保护**：必须确保setup.s（操作系统初始化代码）正确加载
- **死循环保险**：若始终失败会无限重试（实际硬件应有超时机制）

16. **寄存器值对比表**：

| 操作阶段        | AX    | DX    | CX    | BX    |
|-----------------|-------|-------|-------|-------|
| 初始读取        | 0204h | 0000h | 0002h | 0200h |
| 错误处理复位    | 0000h | 0000h | -     | -     |

17. **内存映射示意**：
0x90000: bootsect.s (已加载)
0x90200: setup.s (正在加载的目标位置)
      ↓
      +----------+ 尝试读取
      | 扇区2-5  |
      +----------+
若失败则重新尝试

18. **技术演进对比**：
- 现代UEFI：使用异步操作和事件通知
- 传统BIOS：同步操作+主动轮询状态
- 共同点：都需要错误检测和恢复机制

这个错误处理机制体现了早期操作系统开发的两个重要特征：
19. **硬件直接控制**：需要精确处理底层硬件的不稳定性
20. **防御性编程**：在关键路径上必须确保操作成功

类似现代开发中的重试机制：
```python
max_retries = 3
for _ in range(max_retries):
    try:
        read_disk()
        break
    except IOError:
        reset_disk()
```

思考题：为什么复位操作（AH=0x00）后不需要重新设置其他寄存器？
因为之前的寄存器值（DX/CX/BX）仍然保留着正确的参数值，复位操作仅重置磁盘控制器状态，不影响后续参数设置。